Option Explicit

Sub PopulatePPT_From_Excel()
    Dim excelApp As Object, wb As Object
    Dim runMode As VbMsgBoxResult
    Dim folderPath As String, filePath As String, fileName As String

    runMode = MsgBox("Process multiple Excel files (Batch Mode)?", vbYesNoCancel + vbQuestion, "Select Mode")
    If runMode = vbCancel Then Exit Sub

    '--- Excel instance ---
    On Error Resume Next
    Set excelApp = GetObject(Class:="Excel.Application")
    If excelApp Is Nothing Then Set excelApp = CreateObject("Excel.Application")
    On Error GoTo 0
    excelApp.Visible = False

    '--- Single file ---
    If runMode = vbNo Then
        With Application.FileDialog(msoFileDialogFilePicker)
            .Title = "Select Excel File"
            .Filters.Add "Excel Files", "*.xls;*.xlsx;*.xlsm"
            If .Show <> -1 Then Exit Sub
            filePath = .SelectedItems(1)
        End With
        ProcessOneFile excelApp, filePath
        excelApp.Quit
        Set excelApp = Nothing
        MsgBox "PowerPoint created successfully!", vbInformation
        Exit Sub
    End If

    '--- Batch mode ---
    With Application.FileDialog(msoFileDialogFolderPicker)
        .Title = "Select Folder containing Excel Files"
        If .Show <> -1 Then Exit Sub
        folderPath = .SelectedItems(1)
    End With
    If Right(folderPath, 1) <> "\" Then folderPath = folderPath & "\"

    fileName = Dir(folderPath & "*.xls*")
    Do While fileName <> ""
        ProcessOneFile excelApp, folderPath & fileName
        fileName = Dir()
    Loop

    excelApp.Quit
    Set excelApp = Nothing
    MsgBox "All PowerPoints created successfully!", vbInformation
End Sub


'==========================================================
'=== Core routine for one workbook =========================
'==========================================================
Private Sub ProcessOneFile(excelApp As Object, filePath As String)
    Dim wb As Object, ws As Object, entityType As String
    Dim sld As Object, newPres As Presentation, basePres As Presentation
    Dim tbl As Object, rng As Object
    Dim headers As Variant, dataRow As Variant
    Dim col As Long, usedHeaders As Collection
    Dim txt As String, outText As String
    Dim dynamicHeaders() As String, addHdr As String
    Dim dynCount As Long
    Dim pptName As String

    On Error Resume Next
    Set wb = excelApp.Workbooks.Open(filePath)
    Set ws = wb.Sheets("Dashboard")
    On Error GoTo 0
    If ws Is Nothing Then Exit Sub

    entityType = LCase(Trim(ws.Range("C24").Value))
    headers = ws.Range("B2:M2").Value
    dataRow = ws.Range("B3:M3").Value

    Set usedHeaders = New Collection
    For col = 1 To 12
        If Trim(dataRow(1, col)) <> "" Then usedHeaders.Add headers(1, col)
    Next col

    Set basePres = ActivePresentation

    '--- Copy proper slide to new presentation ---
    If entityType = "internal" Then
        basePres.Slides(1).Copy
    Else
        basePres.Slides(2).Copy
    End If
    Set newPres = Presentations.Add(msoTrue)
    newPres.Slides.Paste
    Set sld = newPres.Slides(1)

    '--- Always populate overview & developments ---
    PopulateSection sld, "CompanyOverview", "CompanyOverviewHeader", ws, "Company Overview"
    PopulateSection sld, "KeyDevelopments", "KeyDevelopmentsHeader", ws, "Key Developments"

    If entityType = "internal" Then
        '--- Table ---
        On Error Resume Next
        Set tbl = sld.Shapes("Table_KeyFinancials").Table
        On Error GoTo 0
        If Not tbl Is Nothing Then
            Set rng = ws.Range("C7:E16")
            FillFinancialTable tbl, rng
        End If

        '--- 4th dynamic section ---
        addHdr = GetExtraHeader(usedHeaders, Array("Company Overview", "Key Developments", "Key Financials"))
        If addHdr <> "" Then
            PopulateDynamic sld, "txt_box", addHdr, ws
            SafeSetHeaderText sld, "SubHeader1", addHdr
        End If

        '--- Subheaders (fixed) ---
        SafeSetHeaderText sld, "CompanyOverviewHeader", "Company Overview"
        SafeSetHeaderText sld, "KeyDevelopmentsHeader", "Key Developments"
        SafeSetHeaderText sld, "KeyFinancialsHeader", "Key Financials"

    ElseIf entityType = "external" Then
        '--- Two dynamic sections ---
        dynamicHeaders = GetExtraHeadersArray(usedHeaders, Array("Company Overview", "Key Developments"), 2)
        dynCount = UBound(dynamicHeaders)
        If dynCount >= 1 And dynamicHeaders(1) <> "" Then
            PopulateDynamic sld, "txt_box3", dynamicHeaders(1), ws
            SafeSetHeaderText sld, "SubHeader1", dynamicHeaders(1)
        End If
        If dynCount >= 2 And dynamicHeaders(2) <> "" Then
            PopulateDynamic sld, "txt_box4", dynamicHeaders(2), ws
            SafeSetHeaderText sld, "SubHeader2", dynamicHeaders(2)
        End If

        SafeSetHeaderText sld, "CompanyOverviewHeader", "Company Overview"
        SafeSetHeaderText sld, "KeyDevelopmentsHeader", "Key Developments"
    End If

    '--- Company name ---
    On Error Resume Next
    sld.Shapes("CompanyName").TextFrame.TextRange.Text = Trim(ws.Range("C22").Value)
    On Error GoTo 0

    '--- Save new file without overwriting template ---
    pptName = Replace(filePath, ".xlsx", "_AutoGen.pptx")
    pptName = Replace(pptName, ".xlsm", "_AutoGen.pptx")
    pptName = Replace(pptName, ".xls", "_AutoGen.pptx")
    newPres.SaveAs pptName
    newPres.Close
    wb.Close SaveChanges:=False
End Sub


'==========================================================
'=== Core section population ==============================
'==========================================================
Private Sub PopulateSection(sld As Object, shpName As String, hdrName As String, ws As Object, headerTitle As String)
    Dim col As Long, txt As String, outText As String
    col = FindHeaderColumn(ws, headerTitle)
    If col = 0 Then Exit Sub
    txt = CStr(ws.Cells(3, col).Value)
    Select Case headerTitle
        Case "Company Overview"
            outText = BuildBulletsFromHyphens(txt)
        Case "Key Developments"
            outText = BuildKeyDevBullets(txt)
        Case "Key Management", "Ownership"
            outText = BuildOwnershipBullets(txt)
        Case Else
            outText = BuildBulletsFromHyphens(txt)
    End Select
    ApplyBulletedText_Simple sld.Shapes(shpName), outText
    SafeSetHeaderText sld, hdrName, headerTitle
    If headerTitle = "Key Developments" Then FormatKeyDevDates sld.Shapes(shpName)
End Sub


'==========================================================
'=== Populate dynamic text boxes ==========================
'==========================================================
Private Sub PopulateDynamic(sld As Object, shpName As String, headerTitle As String, ws As Object)
    Dim col As Long, txt As String, outText As String
    col = FindHeaderColumn(ws, headerTitle)
    If col = 0 Then Exit Sub
    txt = CStr(ws.Cells(3, col).Value)
    Select Case headerTitle
        Case "Key Management", "Ownership"
            outText = BuildOwnershipBullets(txt)
        Case "Key Developments"
            outText = BuildKeyDevBullets(txt)
        Case Else
            outText = BuildBulletsFromHyphens(txt)
    End Select
    ApplyBulletedText_Simple sld.Shapes(shpName), outText
    If headerTitle = "Key Developments" Then FormatKeyDevDates sld.Shapes(shpName)
End Sub


'==========================================================
'=== Utility helpers ======================================
'==========================================================
Private Function FindHeaderColumn(ws As Object, headerName As String) As Long
    Dim i As Long
    For i = 2 To 13
        If Trim(LCase(ws.Cells(2, i).Value)) = LCase(headerName) Then
            FindHeaderColumn = i
            Exit Function
        End If
    Next i
    FindHeaderColumn = 0
End Function

Private Function GetExtraHeader(col As Collection, skipList As Variant) As String
    Dim h As Variant, s As Variant, skip As Boolean
    For Each h In col
        skip = False
        For Each s In skipList
            If LCase(h) = LCase(s) Then skip = True: Exit For
        Next s
        If Not skip Then GetExtraHeader = h: Exit Function
    Next h
End Function

Private Function GetExtraHeadersArray(col As Collection, skipList As Variant, needCount As Long) As String()
    Dim arr() As String, h As Variant, s As Variant, skip As Boolean, c As Long
    ReDim arr(0 To needCount)
    For Each h In col
        skip = False
        For Each s In skipList
            If LCase(h) = LCase(s) Then skip = True: Exit For
        Next s
        If Not skip Then
            c = c + 1
            If c <= needCount Then arr(c) = h
        End If
    Next h
    GetExtraHeadersArray = arr
End Function

Private Sub FillFinancialTable(tbl As Object, rng As Object)
    Dim i As Long, j As Long, minRows As Long, minCols As Long
    Dim refFontName As String, refFontSize As Single, refFontColor As Long
    On Error Resume Next
    With tbl.Cell(1, 1).Shape.TextFrame.TextRange.Font
        refFontName = .Name: refFontSize = .Size: refFontColor = .Color.RGB
    End With
    On Error GoTo 0
    If Len(refFontName) = 0 Then refFontName = "Calibri"
    If refFontSize = 0 Then refFontSize = 11
    If refFontColor = 0 Then refFontColor = RGB(0, 0, 0)
    minRows = MinLong(tbl.Rows.Count, rng.Rows.Count)
    minCols = MinLong(tbl.Columns.Count - 1, rng.Columns.Count)
    For i = 1 To minRows
        For j = 2 To minCols + 1
            tbl.Cell(i, j).Shape.TextFrame.TextRange.Text = CStr(rng.Cells(i, j - 1).Text)
            With tbl.Cell(i, j).Shape.TextFrame.TextRange.Font
                .Name = refFontName
                .Size = refFontSize
                If i > 1 And refFontColor = RGB(255, 255, 255) Then
                    .Color.RGB = RGB(0, 0, 0)
                Else
                    .Color.RGB = refFontColor
                End If
            End With
        Next j
    Next i
End Sub

Private Sub SafeSetHeaderText(sld As Object, hdrName As String, newText As String)
    On Error Resume Next
    Dim tr As Object
    Set tr = sld.Shapes(hdrName).TextFrame.TextRange
    If Not tr Is Nothing Then tr.Text = newText
    On Error GoTo 0
End Sub

Private Sub FormatKeyDevDates(shp As Object)
    Dim regex As Object, matches As Object, m As Object, tr As Object, dateText As String
    Set regex = CreateObject("VBScript.RegExp")
    regex.Global = True: regex.Pattern = "(\b\d{1,2}\s[A-Za-z]{3}\s\d{4}:)"
    Set tr = shp.TextFrame.TextRange
    Set matches = regex.Execute(tr.Text)
    For Each m In matches
        dateText = UCase$(m.Value)
        tr.Characters(m.FirstIndex + 1, Len(m.Value)).Text = dateText
        With tr.Characters(m.FirstIndex + 1, Len(dateText)).Font
            .Bold = True
            .Color.RGB = RGB(49, 134, 155)
            .Name = "Arial"
            .Size = 10
        End With
    Next m
End Sub

Private Function MinLong(a As Long, b As Long) As Long
    If a < b Then MinLong = a Else MinLong = b
End Function


'==========================================================
'=== Formatting builders ==================================
'==========================================================
Private Sub ApplyBulletedText_Simple(shp As Object, ByVal textBody As String)
    With shp.TextFrame
        .AutoSize = 0
        .TextRange.Text = Trim$(textBody)
    End With
    With shp.TextFrame.TextRange.ParagraphFormat.Bullet
        .Visible = True
        .Character = 8226
    End With
    With shp.TextFrame.TextRange.Font
        .Name = "Calibri"
        .Size = 12
    End With
End Sub

Private Function BuildBulletsFromHyphens(ByVal s As String) As String
    Dim parts As Variant, p As Variant, outText As String
    s = Replace(Replace(Replace(s, vbCrLf, " "), vbCr, " "), vbLf, " ")
    parts = Split(s, "- ")
    For Each p In parts
        If Len(Trim$(p)) > 0 Then outText = outText & Trim$(p) & vbCrLf
    Next p
    BuildBulletsFromHyphens = Trim$(outText)
End Function

Private Function BuildKeyDevBullets(ByVal s As String) As String
    Dim regex As Object, matches As Object, i As Long, starts() As Long, ends() As Long, outText As String
    s = Replace(s, vbCr, " "): s = Replace(s, vbLf, " ")
    Set regex = CreateObject("VBScript.RegExp")
    regex.Global = True: regex.Pattern = "(\b\d{1,2}\s[A-Za-z]{3}\s\d{4}:)"
    Set matches = regex.Execute(s)
    If matches.Count = 0 Then BuildKeyDevBullets = Trim$(s): Exit Function
    ReDim starts(0 To matches.Count - 1): ReDim ends(0 To matches.Count - 1)
    For i = 0 To matches.Count - 1: starts(i) = matches(i).FirstIndex + 1: Next i
    For i = 0 To UBound(starts)
        If i < UBound(starts) Then ends(i) = starts(i + 1) - 1 Else ends(i) = Len(s)
    Next i
    For i = 0 To UBound(starts)
        outText = outText & Trim$(Mid$(s, starts(i), ends(i) - starts(i) + 1)) & vbCrLf
    Next i
    BuildKeyDevBullets = Trim$(outText)
End Function

Private Function BuildOwnershipBullets(ByVal s As String) As String
    Dim tmp As String, lines As Variant, ln As Variant, parts As Variant
    Dim nameStr As String, titleStr As String, outText As String
    s = Replace(Replace(Replace(Replace(s, """", ""), "'", ""), vbCrLf, vbLf), vbCr, vbLf)
    lines = Split(s, vbLf)
    For Each ln In lines
        ln = Trim$(ln)
        If Len(ln) = 0 Then GoTo Nxt
        If Left$(ln, 1) = "-" Or Left$(ln, 1) = "–" Then ln = Mid$(ln, 2)
        If InStr(ln, "–") > 0 Then parts = Split(ln, "–", 2) ElseIf InStr(ln, "-") > 0 Then parts = Split(ln, "-", 2) Else parts = Array(ln, "")
        nameStr = Trim$(parts(0))
        If UBound(parts) > 0 Then titleStr = Trim$(parts(1))
        If Len(titleStr) > 0 Then outText = outText & titleStr & ": " & nameStr & vbCrLf Else outText = outText & nameStr & vbCrLf
Nxt:
    Next ln
    BuildOwnershipBullets = Trim$(outText)
End Function
